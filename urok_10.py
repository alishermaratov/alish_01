# """бинарный поиск хариянов в массиве"""
# ВНИМАНИЯ чтобы можно было искать бинарные обьекты(цифры ) обязаьельно массив должен быть отсортерован
# например мы ищем в массиве цифру которого нет и как можно найти эта цифра может стоять между цифрами вот тогда та что справа больше left_boundary та что слева то что меньше
#искать правуб и левую границу цифры которого нет
#каждому и сортировке и нахождению границ будет отдельная функция
"""рекурентная функция"""
def left_bound(a,key):#переменная далась и а это массив а key это цифра которую ищем в этом массиве
    left=-1#это из за того что у нас правая половина меньше надо начинать с -1
    rigth=len(a) #а правая больше из-за этого и правая важная и до конца до лен будет идти
    while rigth-left>1:#если они все больше 1 то херачат цикл
        middle=(left+rigth)//2#тут находят серидину
        if a[middle]<key: #а тут думают если кей больше чем индекс списка а то они равны в райд
            left=middle
        else:
            rigth=middle# если не равны то значит на первой половине
    return rigth

# a=[1,2,5,5,6,7,8,9,10]
# c=4
# d= left_bound(a,c)
# print(d)

"""динамическая прогромирования"""
"""число фибоначи"""
def fib(n):
    if n<=1:#если цифра равна 1 илииноль это по фибоначи будет та цифра которую ввел
        return n
    return (fib(n-1)+fib(n-2)) #если введенный индекс больше чем 1 или ноль то идет расчет числа фибоначи


# c=fib(60)
# print(c)


"""второе вычесления уже линейное а не по дереву"""
#fib=[0,1]+[0]*(n-1)
for i in range(2, n+1):
    fib[i]=fib[i-1]+fib[i-2]

    """кузнечик"""
def traj_num(n):
    k=[0,1]+[0]*n
    for i in range(2,n+1):
        k[i]=k[i-2]+k[i-1]
    return k[n]



"""   ДВУМЕРНЫЕ МАССИВЫ """
""" это первый путь A[i,j]=A[i*m*j] m=элементы в массиве ----------делает линейный а не дерево. ширина массива должна быть заранее известна и зафиксированна"""
""" второй путь список списков A=[[0]+m]*n заполняю массив м раз так как количество такое и умнажаю на значения которое будет даваться"""
#A=[[0]*m  for i in range(n)]
